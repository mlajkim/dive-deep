# Goal

The goal of this document is to dive deep into the following commands:
```sh
cd /
cd -
cd
cd ..
```

# Target Audience
This document is intended for users who have a basic understanding of Linux command line operations and wish to deepen their knowledge of directory navigation commands, with simple copy-paste examples.

# TOC
<!-- TOC -->

- [Goal](#goal)
- [Target Audience](#target-audience)
- [TOC](#toc)
- [Backgrounds](#backgrounds)
- [Dive in](#dive-in)
  - [How to check source code of `cd` command?](#how-to-check-source-code-of-cd-command)
  - [How do we know which shell we are using?](#how-do-we-know-which-shell-we-are-using)
  - [Let's quickly check the version](#lets-quickly-check-the-version)
  - [Dive into the source code of `cd`'s `bin_cd` command in `zsh`](#dive-into-the-source-code-of-cds-bin_cd-command-in-zsh)
    - [Restricted shell check](#restricted-shell-check)
    - [cd with chasing symbolic links](#cd-with-chasing-symbolic-links)
      - [setopt](#setopt)
        - [How to check the options set in your shell?](#how-to-check-the-options-set-in-your-shell)
      - [How to check what options are not yet enabled in your shell?](#how-to-check-what-options-are-not-yet-enabled-in-your-shell)
    - [Signal handling for control the signals during `cd` execution](#signal-handling-for-control-the-signals-during-cd-execution)
    - [zpushnode(dirstack, ztrdup(pwd));](#zpushnodedirstack-ztrduppwd)
    - [Dive into `cd_get_dest()`](#dive-into-cd_get_dest)
      - [if (!argv[0])](#if-argv0)
    - [Dive into cd_do_chdir()](#dive-into-cd_do_chdir)
    - [Dive into cd_new_pwd()](#dive-into-cd_new_pwd)
- [Others](#others)
  - [First time seeing 25 years old commit](#first-time-seeing-25-years-old-commit)

<!-- /TOC -->

# Backgrounds
If you have had a chance to work with Linux, the commands above are pretty common for navigating through directories. You may already know what they do, but let's dive deep into each of them to understand their behaviors.
- `cd /:` Navigates to the Root directory
- `cd ..:` Navigates to the Parent directory
- `cd:` Navigates to the Home directory (equivalent to `cd ~`)
- `cd -:` Navigates to the Previous directory

While the first three are straightforward, `cd -` behaves like a "Back" button. But how does the shell remember where I was?

# Dive in

## How to check source code of `cd` command?

```sh
type cd
# cd is a shell builtin
```

`shell builtin` means that the command `cd` is implemented directly within the shell (like `bash`, `zsh`, etc.)


## How do we know which shell we are using?
```sh
echo $SHELL
# /bin/zsh
```

OR you may:
```sh
echo $0
# -zsh
```

## Let's quickly check the version


```sh
/bin/zsh --version
# or: `zsh --version`
# zsh 5.9 (arm64-apple-darwin24.0)
```

## Dive into the source code of `cd`'s `bin_cd` command in `zsh`

> [!INFO]
> The following is a mirror link of the official repository of `zsh`

https://github.com/zsh-users/zsh

The core functions are the following:
- `cd_get_dest()`: does the initial argument processing
- `cd_do_chdir()`: actually changes directory, if possible
- `cd_new_pwd()`: does the ancillary processing associated with actually changing directory

### Restricted shell check

```c
if (isset(RESTRICTED)) {
	zwarnnam(nam, "restricted");
	return 1;
}
```

> [!INFO]
> zwarnnam is a compound word for: `z`(ZSH) + `warn` (WARNING) + `nam` (NAME)
> A function for error output with consistent formatting.

This code checks if the shell is running in restricted mode by using the `isset(RESTRICTED)` function. If it is, it issues a warning message "restricted" using the `zwarnnam` function and returns `1`, indicating an error. In restricted mode, certain commands, including changing directories - `cd` -, may be limited to enhance security.

Will return the following output when you try to use `cd` in restricted mode:

Prepare restricted shell:
```sh
zsh -r
# shell_session_history_enable:1: /usr/bin/touch: restricted
# shell_session_history_enable:2: HISTFILE: restricted
```

```sh
# cd ..
zsh: cd: restricted
```



### cd with chasing symbolic links

```c
chasinglinks = OPT_ISSET(ops,'P') || (isset(CHASELINKS) && !OPT_ISSET(ops,'L'));
```

`chasinglinks` is a boolean value, meaning is_chasing_symbolic_links or not.
It is `true` if :
- If user specifies `-P` option
- If user has a preference setting CHASELINKS enabled
  - You can temporarily override this setting by specifying `-L` option


Setup:
```sh
tmp_dir=$(date +%y%m%d_%H%M%S_test)
mkdir $tmp_dir && cd $tmp_dir
mkdir physical_path
ln -s physical_path symbolic_link
```

Check Setup:
```sh
ls -al
# total 0
# drwxr-xr-x   4 ajk  staff   128 Nov 29 13:58 .
# drwxr-x---+ 73 ajk  staff  2336 Nov 29 13:54 ..
# drwxr-xr-x   3 ajk  staff    96 Nov 29 13:58 physical_path
# lrwxr-xr-x   1 ajk  staff    13 Nov 29 13:58 symbolic_link -> physical_path
```

Test yourself:
```sh
cd symbolic_link
pwd
# /path/to/your/tmp_dir/symbolic_link
```

Test with `-P` option:
```sh
cd ..
cd -P symbolic_link
pwd
# /path/to/your/tmp_dir/physical_path
```

Test with `CHASE_LINKS` enabled:
```sh
cd ..
setopt CHASE_LINKS
cd symbolic_link
pwd
# /path/to/your/tmp_dir/physical_path
```

Override the `CHASE_LINKS` with `-L` option:
```sh
cd ..
cd -L symbolic_link
pwd
# /path/to/your/tmp_dir/symbolic_link
```

#### setopt

the command `setopt` is in `Src/options.c`

##### How to check the options set in your shell?

```c
/* With no arguments or options, display options. */
if (!*args) {
	scanhashtable(optiontab, 1, 0, OPT_ALIAS, optiontab->printnode, !isun);
	return 0;
}
```

```sh
setopt
# chaselinks
# combiningchars
# interactive
# ...
```

#### How to check what options are not yet enabled in your shell?

```sh
unsetopt
# noaliases
# aliasfuncdef
# allexport
# ...
```

### Signal handling for control the signals during `cd` execution

```sh
queue_signals();
```

Make sure that other signals (like interrupts) do not interfere with the execution of the `cd` command. This is important because changing directories is a critical operation, and we want to ensure it completes without interruption.

### zpushnode(dirstack, ztrdup(pwd));

`pwd` contains the current working directory before changing it.

You can check `dirstack` by:

```sh
dirs -v
0	~/Workspaces
1	~/Workspaces/oss
```

### Dive into `cd_get_dest()`

`cd_get_dest` returns the destination directory based on the arguments provided to the `cd` command. It handles various cases, such as:
- No arguments: returns the home directory
- `-`: returns the previous directory from the directory stack
- Specific path: returns the specified path

It returns `NULL` if there is an error, such as when the previous directory is not set.

Also it is shared by the following commands (Please note that they had to do this for performance/size optimization back in the days when memory and storage were more limited):
- `cd`
- `pushd`
- `popd`

#### if (!argv[0])

If argument is empty:

> [!INFO]
> `popd` stands for "pop directory" and is used to remove the top entry from the directory stack and change the current working directory to that entry.

```c
if (func == BIN_POPD && !nextnode(firstnode(dirstack))) {
  zwarnnam(nam, "directory stack empty");
  return NULL;
}
```

You can manipulate this error log when your directory stack is empty:

```sh
# dirs -v
# 0	~/Workspaces/directory
popd
# popd: directory stack empty
```


### Dive into cd_do_chdir()
ðŸŸ¡

### Dive into cd_new_pwd()
ðŸŸ¡
# Others

## First time seeing 25 years old commit

![25_years_ago_commit](/assets/25_years_ago_commit.png)
